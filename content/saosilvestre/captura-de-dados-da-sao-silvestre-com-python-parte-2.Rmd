Title: Captura de dados da Corrida de São Silvestre com Python—Parte 2
Category: data science
Author: Wilson Freitas
Tags: R, dplyr
Date: 2015-04-27
Lang: pt

```{r, echo=FALSE}
hook_plot <- knit_hooks$get('plot')
knit_hooks$set(plot=function(x, options) {
    if (!is.null(options$pelican.publish) && options$pelican.publish) {
        x <- paste0("{filename}../", x)
    }
    hook_plot(x, options)
})
opts_chunk$set(pelican.publish=TRUE)
```


[saosilvestre]: https://github.com/wilsonfreitas/saosilvestre
[parte-1]: {filename}captura-de-dados-da-sao-silvestre-com-python.md

No post [Captura de dados da Corrida de São Silvestre com Python—Parte 1][parte-1] eu levanto uma questão: Como o clima influencia o desempenho dos corredores de rua?
Nesse post eu apresento como os dados dos campeões da corrida de São Silvestre foram capturados do site da corrida utilizando Python e em seguida transformados em um arquivos CSV.

Agora vou mostrar como o arquivo CSV foi utilizado, como os dados foram limpos e como foram formatados para que eu tenha os tipos corretos para a análise dos dados.
Neste post eu uso R ao invés de Python, sem nenhuma razão específica.

## Montando o ambiente

Para fazer esta análise eu carreguei os seguintes pacotes:

```{r, message=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(lubridate)
```

O `ggplot2` é para fazer gráficos, `dplyr` e `tidyr` para tratar os *datasets* e `lubridate` para manipulação de data e hora.
Pessoalmente acho o `dplyr` excepcional para o manejo com os dados, ele impõe uma forma fluida de pensar nas colunas do *dataset* como variáveis e a partir daí todo o processo de manipulação de dados se torna simples.

## Carregando os dados

Vamos começar carregando o arquivo `saosilvestre.csv`.

```{r message=FALSE}
library(RCurl)
csv_file <- getURL('https://raw.githubusercontent.com/wilsonfreitas/saosilvestre/master/saosilvestre.csv')
ss <- read.csv(text=csv_file, header=TRUE, stringsAsFactor=FALSE)
head(ss)
```

Eu não vou utilizar as colunas `largada`, `chegada` e `horario` e como elas poluem a vizualização do *dataset* eu decidi removê-las:

```{r}
ss <- ss %>% select(-largada, -chegada, -horario)
head(ss)
```

Muito melhor!

> **Importante:** o operador `%>%` é um *pipe* e compõe as sucessivas chamadas de funções para transformações em um *dataset*.
> O retorno da primeira expressão é atribuído ao primeiro argumento da função na segunda expressão, e caso houvessem mais expressões esse comportamento se repetiria até encontrar a última expressão e retornar o seu resultado para o chamador.
> Este operador, que é extensamente utilizado em conjunto com as funções do `dplyr`, tem origem no pacote [`magrittr`](https://github.com/smbache/magrittr).


## Limpando e formatando os dados

Para ter o *dataset* pronto para uso eu preciso formatar os dados e corrigir os erros.
No processo de análise eu encontrei alguns erros e como não será possível reproduzir este processo aqui eu vou listar os erros e apresentar as soluções.

### Corrigindo o `ano`

O `ano` da corrida número 90 está errado.
Este erro pode ser observado olhando os dados, veja na listagem abaixo onde eu uso a função `filter` do `dplyr` para selecionar os registros em que a coluna `corrida` é 90.

```{r}
ss %>% filter(corrida == 90)
```

Para corrigir isso é necessário definir para 2014 o `ano` dos registros que possuem `corrida` igual a 90.

```{r}
ss <- ss %>% mutate(ano=ifelse(corrida == 90, 2014, ano))
```

Apenas para ter certeza vamos verificar os dados após a correção.

```{r echo=FALSE}
ss %>% filter(corrida == 90)
```

Ótimo, `ano` corrigido!

### Corrigindo o `pais`

Na coluna `pais` há registros mau preenchidos, alguns registros estão preenchidos errados e também há registros vazios.
Vou começar com os registros errados, eles estão preenchidos com um hífen `-` e devem ser substituídos pelos países corretos.

```{r show=FALSE}
ss %>% filter(pais == '-')
```

O `pais` do primeiro registro é Brasil e para o segundo é Quênia.
Para corrigir esse erro eu utilizo a função `grep` para identificar os registros errados e substituir a coluna `pais` pelos valores comentados, mas mantendo a ordem correta, que eu consigo saber observando a listagem acima.

```{r}
idx <- grep('^-', ss$pais)
ss[idx[1], 'pais'] <- 'Brasil'
ss[idx[2], 'pais'] <- 'Quênia'
```

Há também um registro com `pais` vazio.

```{r show=FALSE}
ss %>% filter(pais == '')
```

O `pais` para este registro é Brasil e como é apenas 1 fica fácil corrigir com `dplyr::mutate`.

```{r}
ss <- ss %>% mutate(pais=ifelse(pais == '', 'Brasil', pais))
```

Pronto, `pais` corrigido.

### Corrigindo o `percurso`

Há 1 registro com erro na coluna `percurso`, e esse foi *tricky* para descobrir.
Fazendo o gráfico de percurso por ano posso observar que a partir da década de 90 os percursos se mantém constantes em 15 km.

```{r ano-percurso}
ggplot(data=ss, aes(x=ano, y=percurso)) + geom_point(size=2) + geom_line()
```

Entretanto, logo após o ano 2000 há um ponto que caí vertiginosamente de 15 km para aproximadamente a metade.
Observando o gráfico vejo que há variações semelhantes, porém isso pode me levar a questionar os demais valores.
Por isso eu somente consegui identificar este erro quando criei a variável `pace` que mede a quantidade de tempo que um corredor leva para percorrer 1 km.
Eu converto a variável `tempo` que é um `character` para `difftime` que é um objeto que representa intervalos de tempo.
Pessoalmente acho `difftime` um nome miserável de ruim, mas no R algumas coisas são assim mesmo, meio feias ;).
Depois dessa conversão eu consigo fazer as operações aritiméticas com `difftime` necessárias para o cálculo do `pace`.

```{r}
ss <- ss %>% mutate(tempo=as.difftime(tempo), pace=1000*tempo/percurso)
```

Fazendo o gráfico do *pace* dos campeões por corrida temos:

```{r ano-pace}
ggplot(data=ss, aes(x=ano, y=as.numeric(pace))) + geom_point(size=2) + geom_line()
```

Bingo! É possível notar que no mesmo ano que no gráfico anterior há um *outliar*.
Os paces de campeões são abaixo de 4 min/km, em média, de forma que um pace de 6 min/km é implausível.
Para corrigir este registro vou assumir que ele é 15 km, como os demais em anos próximos.
Dessa forma, será necessário atualizar o `percurso` e calcular novamente o `pace`.
Para corrigir o percurso vou utilizar as operações de indexação no `data.frame` junto com a função `which` e para recalcular o pace eu utilizo a mesma expressão de antes (com `mutate`).

```{r}
ss[which(ss$pace > 4),]$percurso <- 15000
ss <- ss %>% mutate(pace=1000*tempo/percurso)
```

Gerando novamente o gráfico dos paces observo que o erro está corrigido.

```{r ano-pace-corrigido, echo=FALSE}
ggplot(data=ss, aes(x=ano, y=as.numeric(pace))) + geom_point(size=2) + geom_line()
```

> **Importante:** é necessário converter o `pace`, que é um `difftime`, para `numeric` para construir o gráfico com ggplot2.

> **Importante:** notei no gráfico dos paces que nos anos recentes há dois níveis distintos de pace. Isso refere-se aos paces masculino e feminino que vamos classificar em breve.


### Classificando masculino e feminino: criando `sexo`

Como observei nos gráficos de pace, há uma diferença entre os paces: masculino e feminino, de forma que é interessante que eu consiga classificar os corredores quanto ao sexo.
Eu sei que o tempo masculino é menor que o feminino, ou seja, um campeão do sexo masculino percorre a distância da prova em menos tempo do que uma campeã.
Então eu posso assumir que nos anos em que há apenas 1 ocorrência, o sexo do campeão é masculino, e quando houverem 2 ocorrências o menor pace é do sexo masculino e o maior é do feminino.
Também estou assumindo que não há provas com mais de 2 gêneros.
Bem, posto isso a estratégia para classificar os campeões pelo sexo é:

1. ordenar por `ano` e `tempo`
2. agrupar por `ano`
3. criar a variável `sexo` considerando sexo masculino quando a contagem do grupo for 1 e (masculino, feminino), nesta ordem, quando a contagem do grupo for diferente de 1

Parece meio confuso mas com `dplyr` isso tudo pode ser resolvido em meia dúzia de linhas.

```{r}
ss <- ss %>%
  arrange(ano, tempo) %>%
  group_by(ano) %>%
  mutate(sexo=if (n() == 1) 'masculino' else c('masculino', 'feminino')) %>%
  ungroup %>%
  as.data.frame
tail(ss)
```

Eu executo um `tail` para apresentar os resultados porque os dados foram ordenados por ano e portanto os últimos registros são os que apresentam provas com os 2 sexos.
Para verificar se a classificação está correta vou fazer um gráfico do tempo por ano agrupando por sexo para ilustrar a classificação dos campeões.
Mas antes vou criar mais uma coluna chamada `contagem`, com a contagem de ocorrências da corrida, essa variável me ajuda a filtar os resultados para apresentar apenas as corridas em que houveram 2 campeões, pois dessa forma eu consigo comparar os níveis de pace por sexo.

```{r ano-tempo-masc-fem}
ss <- ss %>%
  group_by(ano) %>%
  mutate(contagem=n()) %>%
  ungroup %>%
  as.data.frame
ggplot(data=subset(ss, contagem == 2),
       aes(x=ano, y=as.numeric(tempo), group=sexo, colour=sexo)) +
  geom_point(size=2)
```

Este gráfico me intriga porque a é possível observar 3 níveis distintos para o comportamento dos tempos dos campeões.
Isso é um reflexo do percurso da prova, pois o tamanho do percurso aumentou ao longo dos anos até estacionar em 15 km.
Outro gráfico semelhante ao anterior, mas apresentando percurso por ano agrupando por sexo, pode mostrar isso melhor.

```{r ano-percurso-masc-fem}
ggplot(data=subset(ss, contagem == 2),
       aes(x=ano, y=percurso, group=sexo, colour=sexo)) +
  geom_point(size=2)
```

Em todos as provas, exceto na segunda ocorrência do gráfico acima, os percursos masculinos e femininos são iguais.
Este é um forte indício de que o percurso dessa prova para o sexo feminino também está errado.

```{r}
head(subset(ss, contagem == 2))
```

Listando o *dataset* observo que os registros da corrida 52 possuem os diferentes percursos, dessa forma vou assumir que os 2 deveriam ser 8900 m.
Identificado o problema vou seguir com a mesma solução, selecionar os registros da corrida 52 e definir o `percurso` para 8900 m.

```{r}
ss[which(ss$corrida == 52),]$percurso <- 8900
ss <- ss %>% mutate(pace=1000*tempo/percurso)
```

Para encerrar as dúvidas vou empilhar os gráficos de pace e tempo por ano, para avaliar se as hipóteses assumidas são pertinentes.

```{r ano-pace-tempo-masc-fem, message=FALSE}
library(gridExtra)
ss_mw <- subset(ss, contagem == 2)

plot_pace <- ggplot(data=ss_mw, aes(x=ano, y=as.numeric(pace), group=sexo, colour=sexo)) +
  geom_point(size=2)
plot_time <- ggplot(data=ss_mw, aes(x=ano, y=as.numeric(tempo), group=sexo, colour=sexo)) +
  geom_point(size=2)

grid.arrange(plot_pace, plot_time, nrow=2)
```

Neste gráfico observo 2 regimes de pace contra 3 regimes de tempo.
Há 3 regimes de tempo porque o tempo é diretamente proporcional ao percurso, maior o percurso, maior o tempo, e no período avaliado temos 3 percursos: 8900 m, 13 km e 15 km.
Por outro lado os 2 regimes de pace são curiosos pois indicam a relação do pace com o tamanho do percurso, ou seja, maior o percurso, maior o pace, o que é esperado, dado que é difícil para um corredor manter o mesmo nível de esforço em provas de diferentes distância.
No entanto, a diferença de 2 km entre os percursos de 13 km e 15 km não influencia o pace dos campeões.

Outra coisa, estes gráficos me fazem desconfiar de que a diferença do desempenho entre os sexos se mantém constante, em média, indicando algum tipo de estacionariedade, mas ainda seriam necessários mais gráficos e alguns testes estatísticos para comprovar isso.

## Trabalho concluído

Bem, acredito aqui que o trabalho de limpeza e formatação está concluído.
Pude passar por diversos problemas oriundos de uma manutenção pobre dos dados.
O conteúdo das páginas não é confiável e vê-se que a atualização é manual e sem verificações.
No entanto, este é o trabalho de quem tem que garimpar dados na Internet, é necessário criar formas de verificação e validação das hipóteses assumidas.
Ainda falta fazer a análise dos dados para tentar responder a pergunta de como o clima pode influenciar o desempenho dos corredores de rua, mas isso fica pra outro post.
Por ora vou salvar estes dados em um arquivo csv para usar na continuação deste trabalho.


